{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "mada_basic.analog_pins_legacy_",
    "name" : "Analog Pins (Legacy)",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "rpc",
      "sizeX" : 5.5,
      "sizeY" : 4.5,
      "resources" : [ ],
      "templateHtml" : "<div class=\"analog-pins-widget\" fxLayout=\"column\" fxLayoutAlign=\"space-between\" style=\"font-family: Tajawal, Roboto\">\n    <mat-spinner *ngIf=\"isLoading$ | async; else showData\"></mat-spinner>\n    <div id=\"pins-list-container\" fxLayout=\"row wrap\" >\n        <!--<div *ngIf=\"pins && pins.length > 0; else noPins\">-->\n            <div *ngFor=\"let pin of pins; let i = index\" class=\"pin-card\" fxLayout=\"column\" [fxLayoutAlign]=\"isEditMode ? 'start center' : 'center center'\" [attr.data-pin-index]=\"i\">\n                <!--Pin card buttons section-->\n                <div fxLayout fxLayoutAlign=\"space-between\" *ngIf=\"isEditMode\" style=\"width: 100%\">\n                    <button mat-icon-button aria-label=\"Settings icon button\" class=\"pin-card-btn\" (click)=\"openSettingsDialog($event, pin, i)\" matTooltip=\"Pin Settings\" matTooltipPosition=\"above\">\n                        <mat-icon>settings</mat-icon>\n                    </button>\n                    <button mat-icon-button aria-label=\"Delete pin icon button\" class=\"pin-card-btn\" (click)=\"removePin($event, i, pin)\" matTooltip=\"Remove Pin\" matTooltipPosition=\"above\">\n                        <mat-icon>delete</mat-icon>\n                    </button>\n                </div>\n                <div class=\"pin-card-label\">\n                    {{pin.label}}\n                </div>\n                <div class=\"pin-card-gaugeContainer\">\n                    <canvas class=\"pin-card-barGauge\" width=\"0\" height=\"0\"></canvas>\n                    <canvas class=\"pin-card-radialGauge\" style=\"width: 100%\"></canvas>\n                    <div class=\"pin-card-radGaugeValUnit\">\n                        <span class=\"pin-card-radGaugeValue\"></span>\n                        <span class=\"pin-card-radGaugeUnit\">{{pin.unit}}</span>\n                    </div>\n                </div>\n                <div fxLayout fxLayoutAlign=\"space-between\" style=\"width: 100%\">\n                    <!--Pin Node ID Section-->\n                    <div fxLayout=\"column\" fxLayoutAlign=\"center center\" fxFlex=\"60px\">\n                        <div class=\"pin-card-nodeId_label\">Node ID</div>\n                        <div class=\"pin-card-nodeId\">{{pin.nodeId}}</div>\n                    </div>\n                    <!--Pin Number Section-->\n                    <div fxLayout=\"column\" fxLayoutAlign=\"center center\" fxFlex=\"60px\">\n                        <div class=\"pin-card-pinNumber_label\">Pin  #</div>\n                        <div class=\"pin-card-pinNumber\">{{pin.number}}</div>\n                    </div>\n                </div>\n            </div>\n        <!--</div>-->\n        <ng-template #noPins>\n            <div fxLayout fxLayoutAlign=\"center center\" class=\"no-data\">\n                <span>No Data Available</span>\n            </div>\n        </ng-template>\n    </div>\n        \n    <div fxFlex=\"48px\" fxLayoutAlign=\"start\" fxLayoutGap=\"4px\" class=\"analog-widget-actions\" *ngIf=\"!readOnly\">\n        <button mat-icon-button color=\"accent\"\n            aria-label=\"Edit pin icon button\"\n            (click)=\"toggleEditMode()\"\n            [matTooltip]=\"isEditMode ? 'Apply Changes' : 'Edit Mode'\"\n            matTooltipPosition=\"above\">\n            <mat-icon *ngIf=\"!isEditMode; else checkIcon\">edit</mat-icon>\n            <ng-template #checkIcon>\n                <mat-icon>check</mat-icon>\n            </ng-template>\n        </button>\n        <button mat-icon-button color=\"accent\"\n            aria-label=\"Add pin icon button\"\n            (click)=\"addPin()\" matTooltip=\"Add Pin\"\n            matTooltipPosition=\"above\" *ngIf=\"isEditMode\">\n            <mat-icon>add</mat-icon>\n        </button>\n    </div>\n</div>",
      "templateCss" : "#container {\r\n    /*overflow: auto;*/\r\n}\r\n\r\n.analog-pins-widget {\r\n    height: 100%;\r\n}\r\n\r\n#pins-list-container{\r\n    gap: 12px;\r\n    overflow: auto;\r\n    /*background: #efefef;*/\r\n    /*height: 100%;*/\r\n}\r\n\r\n.no-data {\r\n    height: 200px;\r\n}\r\n\r\n.analog-pins-widget .pin-card{\r\n    /*border: 1px solid #CEE9B6;*/\r\n    background: #212121;\r\n    border-radius: 4px;\r\n    padding: 8px;\r\n    width: 320px;\r\n    /*min-width: 260px;*/\r\n    min-height: 320px;\r\n}\r\n\r\n\r\n\r\n.analog-pins-widget .pin-card-btn{\r\n    color: #7d7d7d;\r\n}\r\n\r\n.analog-pins-widget .pin-card-label{\r\n    text-align: center;\r\n    font-size: 22px;\r\n    font-weight: bold;\r\n}\r\n\r\n.pin-card-gaugeContainer{\r\n    position: relative;\r\n    margin-top: 12px;\r\n    /*display: flex;*/\r\n    /*justify-content: center;*/\r\n}\r\n\r\n.pin-card-gaugeContainer canvas{\r\n    /*max-width: 100%;*/\r\n    /*height: 168px;*/\r\n}\r\n\r\n.pin-card-gaugeContainer .pin-card-radGaugeValUnit{\r\n    position: absolute;\r\n    top: 85px;\r\n    left: 0;\r\n    right: 0;\r\n    text-align: center;\r\n    font-size: 24px;\r\n}\r\n\r\n.analog-pins-widget .pin-settings-input{\r\n    display: block; \r\n    height: 38px; \r\n    padding: 5px 8px; \r\n    border: 1px solid #0000001f; \r\n    border-radius: 4px;\r\n}\r\n\r\n.gauge-container {\r\n    display: inline-block;\r\n    margin: 5px 15px;\r\n    padding: 15px 15px;\r\n    /*background: #eee;*/\r\n    min-width: 50px;\r\n}\r\n\r\n.bar-container {\r\n    /*background: #cfd8dc;*/\r\n    margin: 0 auto;\r\n    /*border-radius: 20px;*/\r\n    border: 1px solid #CEE9B6;\r\n    /*overflow: clip;*/\r\n}\r\n\r\n.bar {\r\n    /*width: 20px;*/\r\n    height: 0%;\r\n    /*background: #CEE9B6;*/\r\n    background: linear-gradient(90deg, rgba(138,219,66,1) 0%, rgba(255,239,92,1) 45%, rgba(253,82,71,1) 100%);\r\n}\r\n\r\n.gauge-value {\r\n    margin: 10px 0;\r\n    position: relative;\r\n}\r\n.limits-container {\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n\r\n.analog-pins-widget .pin-card-nodeId_label,\r\n.analog-pins-widget .pin-card-pinNumber_label {\r\n    margin-bottom: 3px;\r\n    font-size: 16px;\r\n    font-weight: bold;\r\n}\r\n\r\n.analog-pins-widget .pin-card-nodeId,\r\n.analog-pins-widget .pin-card-pinNumber {\r\n    font-size: 16px;\r\n}\r\n\r\n.analog-widget-actions { \r\n    padding: 4px 0;\r\n    position: sticky;\r\n}\r\n",
      "controllerScript" : "(function () {\n  var AnimatedText,\n    AnimatedTextFactory,\n    Bar,\n    BaseDonut,\n    BaseGauge,\n    Donut,\n    Gauge,\n    GaugePointer,\n    TextRenderer,\n    ValueUpdater,\n    addCommas,\n    cutHex,\n    formatNumber,\n    mergeObjects,\n    secondsToString,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty,\n    extend = function (child, parent) {\n      for (var key in parent) {\n        if (hasProp.call(parent, key)) child[key] = parent[key];\n      }\n      function ctor() {\n        this.constructor = child;\n      }\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    },\n    indexOf =\n      [].indexOf ||\n      function (item) {\n        for (var i = 0, l = this.length; i < l; i++) {\n          if (i in this && this[i] === item) return i;\n        }\n        return -1;\n      };\n\n  (function () {\n    var browserRequestAnimationFrame,\n      isCancelled,\n      j,\n      lastId,\n      len,\n      vendor,\n      vendors;\n    vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\n    for (j = 0, len = vendors.length; j < len; j++) {\n      vendor = vendors[j];\n      if (window.requestAnimationFrame) {\n        break;\n      }\n      window.requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n      window.cancelAnimationFrame =\n        window[vendor + \"CancelAnimationFrame\"] ||\n        window[vendor + \"CancelRequestAnimationFrame\"];\n    }\n    browserRequestAnimationFrame = null;\n    lastId = 0;\n    isCancelled = {};\n    if (!requestAnimationFrame) {\n      window.requestAnimationFrame = function (callback, element) {\n        var currTime, id, lastTime, timeToCall;\n        currTime = new Date().getTime();\n        timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        id = window.setTimeout(function () {\n          return callback(currTime + timeToCall);\n        }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n      return (window.cancelAnimationFrame = function (id) {\n        return clearTimeout(id);\n      });\n    } else if (!window.cancelAnimationFrame) {\n      browserRequestAnimationFrame = window.requestAnimationFrame;\n      window.requestAnimationFrame = function (callback, element) {\n        var myId;\n        myId = ++lastId;\n        browserRequestAnimationFrame(function () {\n          if (!isCancelled[myId]) {\n            return callback();\n          }\n        }, element);\n        return myId;\n      };\n      return (window.cancelAnimationFrame = function (id) {\n        return (isCancelled[id] = true);\n      });\n    }\n  })();\n\n  secondsToString = function (sec) {\n    var hr, min;\n    hr = Math.floor(sec / 3600);\n    min = Math.floor((sec - hr * 3600) / 60);\n    sec -= hr * 3600 + min * 60;\n    sec += \"\";\n    min += \"\";\n    while (min.length < 2) {\n      min = \"0\" + min;\n    }\n    while (sec.length < 2) {\n      sec = \"0\" + sec;\n    }\n    hr = hr ? hr + \":\" : \"\";\n    return hr + min + \":\" + sec;\n  };\n\n  formatNumber = function () {\n    var digits, num, value;\n    num = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    value = num[0];\n    digits = 0 || num[1];\n    return addCommas(value.toFixed(digits));\n  };\n\n  mergeObjects = function (obj1, obj2) {\n    var key, out, val;\n    out = {};\n    for (key in obj1) {\n      if (!hasProp.call(obj1, key)) continue;\n      val = obj1[key];\n      out[key] = val;\n    }\n    for (key in obj2) {\n      if (!hasProp.call(obj2, key)) continue;\n      val = obj2[key];\n      out[key] = val;\n    }\n    return out;\n  };\n\n  addCommas = function (nStr) {\n    var rgx, x, x1, x2;\n    nStr += \"\";\n    x = nStr.split(\".\");\n    x1 = x[0];\n    x2 = \"\";\n    if (x.length > 1) {\n      x2 = \".\" + x[1];\n    }\n    rgx = /(\\d+)(\\d{3})/;\n    while (rgx.test(x1)) {\n      x1 = x1.replace(rgx, \"$1\" + \",\" + \"$2\");\n    }\n    return x1 + x2;\n  };\n\n  cutHex = function (nStr) {\n    if (nStr.charAt(0) === \"#\") {\n      return nStr.substring(1, 7);\n    }\n    return nStr;\n  };\n\n  ValueUpdater = (function () {\n    ValueUpdater.prototype.animationSpeed = 32;\n\n    function ValueUpdater(addToAnimationQueue, clear) {\n      if (addToAnimationQueue == null) {\n        addToAnimationQueue = true;\n      }\n      this.clear = clear != null ? clear : true;\n      if (addToAnimationQueue) {\n        AnimationUpdater.add(this);\n      }\n    }\n\n    ValueUpdater.prototype.update = function (force) {\n      var diff;\n      if (force == null) {\n        force = false;\n      }\n      if (force || this.displayedValue !== this.value) {\n        if (this.ctx && this.clear) {\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n        diff = this.value - this.displayedValue;\n        if (Math.abs(diff / this.animationSpeed) <= 0.001) {\n          this.displayedValue = this.value;\n        } else {\n          this.displayedValue =\n            this.displayedValue + diff / this.animationSpeed;\n        }\n        this.render();\n        return true;\n      }\n      return false;\n    };\n\n    return ValueUpdater;\n  })();\n\n  BaseGauge = (function (superClass) {\n    extend(BaseGauge, superClass);\n\n    function BaseGauge() {\n      return BaseGauge.__super__.constructor.apply(this, arguments);\n    }\n\n    BaseGauge.prototype.displayScale = 1;\n\n    BaseGauge.prototype.forceUpdate = true;\n\n    BaseGauge.prototype.setTextField = function (textField, fractionDigits) {\n      return (this.textField =\n        textField instanceof TextRenderer\n          ? textField\n          : new TextRenderer(textField, fractionDigits));\n    };\n\n    BaseGauge.prototype.setMinValue = function (minValue, updateStartValue) {\n      var gauge, j, len, ref, results;\n      this.minValue = minValue;\n      if (updateStartValue == null) {\n        updateStartValue = true;\n      }\n      if (updateStartValue) {\n        this.displayedValue = this.minValue;\n        ref = this.gp || [];\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          gauge = ref[j];\n          results.push((gauge.displayedValue = this.minValue));\n        }\n        return results;\n      }\n    };\n\n    BaseGauge.prototype.setOptions = function (options) {\n      if (options == null) {\n        options = null;\n      }\n      this.options = mergeObjects(this.options, options);\n      if (this.textField) {\n        this.textField.el.style.fontSize = options.fontSize + \"px\";\n      }\n      if (this.options.angle > 0.5) {\n        this.options.angle = 0.5;\n      }\n      this.configDisplayScale();\n      return this;\n    };\n\n    BaseGauge.prototype.configDisplayScale = function () {\n      var backingStorePixelRatio,\n        devicePixelRatio,\n        height,\n        prevDisplayScale,\n        width;\n      prevDisplayScale = this.displayScale;\n      if (this.options.highDpiSupport === false) {\n        delete this.displayScale;\n      } else {\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStorePixelRatio =\n          this.ctx.webkitBackingStorePixelRatio ||\n          this.ctx.mozBackingStorePixelRatio ||\n          this.ctx.msBackingStorePixelRatio ||\n          this.ctx.oBackingStorePixelRatio ||\n          this.ctx.backingStorePixelRatio ||\n          1;\n        this.displayScale = devicePixelRatio / backingStorePixelRatio;\n      }\n      if (this.displayScale !== prevDisplayScale) {\n        width = this.canvas.G__width || this.canvas.width;\n        height = this.canvas.G__height || this.canvas.height;\n        this.canvas.width = width * this.displayScale;\n        this.canvas.height = height * this.displayScale;\n        this.canvas.style.width = width + \"px\";\n        this.canvas.style.height = height + \"px\";\n        this.canvas.G__width = width;\n        this.canvas.G__height = height;\n      }\n      return this;\n    };\n\n    BaseGauge.prototype.parseValue = function (value) {\n      value = parseFloat(value) || Number(value);\n      if (isFinite(value)) {\n        return value;\n      } else {\n        return 0;\n      }\n    };\n\n    return BaseGauge;\n  })(ValueUpdater);\n\n  TextRenderer = (function () {\n    function TextRenderer(el, fractionDigits1) {\n      this.el = el;\n      this.fractionDigits = fractionDigits1;\n    }\n\n    TextRenderer.prototype.render = function (gauge) {\n      return (this.el.innerHTML = formatNumber(\n        gauge.displayedValue,\n        this.fractionDigits\n      ));\n    };\n\n    return TextRenderer;\n  })();\n\n  AnimatedText = (function (superClass) {\n    extend(AnimatedText, superClass);\n\n    AnimatedText.prototype.displayedValue = 0;\n\n    AnimatedText.prototype.value = 0;\n\n    AnimatedText.prototype.setVal = function (value) {\n      return (this.value = 1 * value);\n    };\n\n    function AnimatedText(elem1, text) {\n      this.elem = elem1;\n      this.text = text != null ? text : false;\n      AnimatedText.__super__.constructor.call(this);\n      if (this.elem === void 0) {\n        throw new Error(\"The element isn't defined.\");\n      }\n      this.value = 1 * this.elem.innerHTML;\n      if (this.text) {\n        this.value = 0;\n      }\n    }\n\n    AnimatedText.prototype.render = function () {\n      var textVal;\n      if (this.text) {\n        textVal = secondsToString(this.displayedValue.toFixed(0));\n      } else {\n        textVal = addCommas(formatNumber(this.displayedValue));\n      }\n      return (this.elem.innerHTML = textVal);\n    };\n\n    return AnimatedText;\n  })(ValueUpdater);\n\n  AnimatedTextFactory = {\n    create: function (objList) {\n      var elem, j, len, out;\n      out = [];\n      for (j = 0, len = objList.length; j < len; j++) {\n        elem = objList[j];\n        out.push(new AnimatedText(elem));\n      }\n      return out;\n    },\n  };\n\n  Bar = (function () {\n    function Bar(elem1) {\n      this.elem = elem1;\n    }\n\n    Bar.prototype.updateValues = function (arrValues) {\n      this.value = arrValues[0];\n      this.maxValue = arrValues[1];\n      this.avgValue = arrValues[2];\n      return this.render();\n    };\n\n    Bar.prototype.render = function () {\n      var avgPercent, valPercent;\n      if (this.textField) {\n        this.textField.text(formatNumber(this.value));\n      }\n      if (this.maxValue === 0) {\n        this.maxValue = this.avgValue * 2;\n      }\n      valPercent = (this.value / this.maxValue) * 100;\n      avgPercent = (this.avgValue / this.maxValue) * 100;\n      $(\".bar-value\", this.elem).css({\n        width: valPercent + \"%\",\n      });\n      return $(\".typical-value\", this.elem).css({\n        width: avgPercent + \"%\",\n      });\n    };\n\n    return Bar;\n  })();\n\n  BaseDonut = (function (superClass) {\n    extend(BaseDonut, superClass);\n\n    BaseDonut.prototype.lineWidth = 15;\n\n    BaseDonut.prototype.displayedValue = 0;\n\n    BaseDonut.prototype.value = 33;\n\n    BaseDonut.prototype.maxValue = 80;\n\n    BaseDonut.prototype.minValue = 0;\n\n    BaseDonut.prototype.options = {\n      lineWidth: 0.1,\n      colorStart: \"#6f6ea0\",\n      colorStop: \"#c0c0db\",\n      strokeColor: \"#eeeeee\",\n      shadowColor: \"#d5d5d5\",\n      angle: 0.35,\n      radiusScale: 1.0,\n    };\n\n    function BaseDonut(canvas) {\n      this.canvas = canvas;\n      BaseDonut.__super__.constructor.call(this);\n      if (typeof G_vmlCanvasManager !== \"undefined\") {\n        this.canvas = window.G_vmlCanvasManager.initElement(this.canvas);\n      }\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.setOptions();\n      this.render();\n    }\n\n    BaseDonut.prototype.getAngle = function (value) {\n      return (\n        (1 - this.options.angle) * Math.PI +\n        ((value - this.minValue) / (this.maxValue - this.minValue)) *\n          (2 + this.options.angle - (1 - this.options.angle)) *\n          Math.PI\n      );\n    };\n\n    BaseDonut.prototype.setOptions = function (options) {\n      if (options == null) {\n        options = null;\n      }\n      BaseDonut.__super__.setOptions.call(this, options);\n      this.lineWidth = this.canvas.height * this.options.lineWidth;\n      this.radius =\n        this.options.radiusScale *\n        (this.canvas.height / 2 - this.lineWidth / 2);\n      return this;\n    };\n\n    BaseDonut.prototype.set = function (value) {\n      this.value = this.parseValue(value);\n      if (this.value > this.maxValue) {\n        if (this.options.limitMax) {\n          this.value = this.maxValue;\n        } else {\n          this.maxValue = this.value;\n        }\n      } else if (this.value < this.minValue) {\n        if (this.options.limitMin) {\n          this.value = this.minValue;\n        } else {\n          this.minValue = this.value;\n        }\n      }\n      AnimationUpdater.add(this);\n      AnimationUpdater.run(this.forceUpdate);\n      return (this.forceUpdate = false);\n    };\n\n    BaseDonut.prototype.render = function () {\n      var displayedAngle, grdFill, h, start, stop, w;\n      displayedAngle = this.getAngle(this.displayedValue);\n      w = this.canvas.width / 2;\n      h = this.canvas.height / 2;\n      if (this.textField) {\n        this.textField.render(this);\n      }\n\n      if (this.options.gradientFill) {\n        grdFill = this.ctx.createConicGradient(0, w, h);\n        grdFill.addColorStop(1, \"#FD5247\");\n        grdFill.addColorStop(0, \"#FD5247\");\n        grdFill.addColorStop(0.2, \"#FD5247\");\n        grdFill.addColorStop(0.3, \"#8ADB42\");\n        grdFill.addColorStop(0.4, \"#8ADB42\");\n        grdFill.addColorStop(0.67, \"#FFEF5C\");\n        grdFill.addColorStop(0.7, \"#FFEF5C\");\n      } else {\n        // grdFill = this.ctx.createRadialGradient(w, h, 39, w, h, 70);\n        // grdFill.addColorStop(0, this.options.colorStart);\n        // grdFill.addColorStop(1, this.options.colorStop);\n        grdFill = this.ctx.createConicGradient(0, w, h);\n        grdFill.addColorStop(1, \"#8ADB42\");\n        grdFill.addColorStop(0.5, \"#FD5247\");\n      }\n      start = this.radius - this.lineWidth / 2;\n      stop = this.radius + this.lineWidth / 2;\n      this.ctx.strokeStyle = this.options.strokeColor;\n      this.ctx.beginPath();\n      this.ctx.arc(\n        w,\n        h,\n        this.radius,\n        (1 - this.options.angle) * Math.PI,\n        (2 + this.options.angle) * Math.PI,\n        false\n      );\n      this.ctx.lineWidth = this.lineWidth;\n      //   this.ctx.lineCap = \"round\";\n      this.ctx.stroke();\n      if (this.value <= this.options.threshold) {\n        this.ctx.beginPath();\n        this.ctx.strokeStyle = \"#8ADB42\";\n        this.ctx.arc(\n          w,\n          h,\n          this.radius,\n          (1 - this.options.angle) * Math.PI,\n          displayedAngle,\n          false\n        );\n        this.ctx.stroke();\n      } else {\n        // this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.strokeStyle = \"#8ADB42\";\n        this.ctx.arc(\n          w,\n          h,\n          this.radius,\n          (1 - this.options.angle) * Math.PI,\n          this.getAngle(this.options.threshold),\n          false\n        );\n        this.ctx.stroke();\n        this.ctx.beginPath();\n        this.ctx.strokeStyle = \"#FD5247\";\n        this.ctx.arc(\n          w,\n          h,\n          this.radius,\n          this.getAngle(this.options.threshold),\n          displayedAngle,\n          false\n        );\n        this.ctx.stroke();\n        // this.ctx.restore();\n      }\n\n      this.renderThresholdIndicator(w, h);\n      // return this.ctx.stroke();\n    };\n\n    BaseDonut.prototype.renderThresholdIndicator = function (cx, cy) {\n      var tipX,\n        tipY,\n        triEdge1X,\n        triEdge1Y,\n        triEdge2X,\n        triEdge2Y,\n        radLineSlope,\n        tanLineSlope;\n    // console.table({cx,cy})\n      var angle = this.getAngle(this.options.threshold);\n      // var angle = this.getAngle(this.options.threshold);\n      var triBase = 15,\n        triHeight = this.lineWidth;\n\n      var offset = this.radius + this.lineWidth / 2;\n\n      tipX = cx + offset * Math.cos(angle);\n      tipY = cy + offset * Math.sin(angle);\n      // Tangent point of the base of the triangle in the imaginary circle\n      var tanX = cx + (offset - triHeight) * Math.cos(angle);\n      var tanY = cy + (offset - triHeight) * Math.sin(angle);\n      // Check if the radius line is vertical (slope is undefined, i.e. slope = Infinity)\n      // if (tanX === tipX) {\n      //   triEdge1X = tanX + triBase / 2;\n      //   triEdge1Y = tanY;\n\n      //   triEdge2X = tanX - triBase / 2;\n      //   triEdge2Y = tanY;\n      // } else {\n      //   radLineSlope = (tipY - tanY) / (tipX - tanX);\n      //   tanLineSlope = -1 / radLineSlope;\n      //   console.table({\n      //     \"Radius Slope\": radLineSlope,\n      //     \"Tangent Slope\": tanLineSlope,\n      //   });\n\n      //   triEdge1X = 55;\n      //   triEdge1Y = tanLineSlope * (triEdge1X - tanX) + tanY;\n\n      //   triEdge2X = tipX + triBase / 2;\n      //   triEdge2Y = tipY + triHeight;\n      // }\n      // triEdge1X = cx + (offset + triBase / 2) * Math.cos(angle);\n      // triEdge1Y = cy + (offset - triHeight) * Math.sin(angle);\n\n      // triEdge2X = tipX + triBase / 2;\n      // triEdge2Y = tipY + triHeight;\n\n      triEdge1X = tipX - triBase / 2;\n      triEdge1Y = tipY + triHeight;\n\n      triEdge2X = tipX + triBase / 2;\n      triEdge2Y = tipY + triHeight;\n\n    //   console.table({\n    //     tipX,\n    //     tipY,\n    //     threshold: this.options.threshold,\n    //     \"angle RAD\": this.options.angle,\n    //     \"angle DEG\": (angle * 180) / Math.PI,\n    //     radius: this.radius,\n    //   });\n\n      this.ctx.save();\n\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = \"#111217\";\n      this.ctx.lineWidth = 3;\n      this.ctx.moveTo(tipX, tipY);\n      this.ctx.lineTo(tanX, tanY);\n      this.ctx.stroke();\n\n      // this.ctx.translate(cx, cy);\n      // this.ctx.rotate(angle - 1.5 * Math.PI);\n      // this.ctx.fillStyle = \"white\";\n      // this.ctx.moveTo(tipX, tipY);\n      // this.ctx.lineTo(triEdge1X, triEdge1Y);\n      // this.ctx.lineTo(triEdge2X, triEdge2Y);\n      // this.ctx.fill();\n\n      this.ctx.restore();\n    };\n\n    return BaseDonut;\n  })(BaseGauge);\n\n  Donut = (function (superClass) {\n    extend(Donut, superClass);\n\n    function Donut() {\n      return Donut.__super__.constructor.apply(this, arguments);\n    }\n\n    Donut.prototype.strokeGradient = function (w, h, start, stop) {\n      var grd;\n      grd = this.ctx.createRadialGradient(w, h, start, w, h, stop);\n      grd.addColorStop(0, this.options._orgStrokeColor);\n      grd.addColorStop(1, this.options._orgStrokeColor);\n      \n    //   grd.addColorStop(0, this.options.shadowColor);\n    //   grd.addColorStop(0.12, this.options._orgStrokeColor);\n    //   grd.addColorStop(0.88, this.options._orgStrokeColor);\n    //   grd.addColorStop(1, this.options.shadowColor);\n      return grd;\n    };\n\n    Donut.prototype.setOptions = function (options) {\n      var h, start, stop, w;\n      if (options == null) {\n        options = null;\n      }\n      Donut.__super__.setOptions.call(this, options);\n      w = this.canvas.width / 2;\n      h = this.canvas.height / 2;\n      start = this.radius - this.lineWidth / 2;\n      stop = this.radius + this.lineWidth / 2;\n      this.options._orgStrokeColor = this.options.strokeColor;\n      this.options.strokeColor = this.strokeGradient(w, h, start, stop);\n      return this;\n    };\n    \n    Donut.prototype.setThreshold = function (threshValue) {\n      this.options.threshold = threshValue;\n    };\n\n    return Donut;\n  })(BaseDonut);\n\n  window.AnimationUpdater = {\n    elements: [],\n    animId: null,\n    addAll: function (list) {\n      var elem, j, len, results;\n      results = [];\n      for (j = 0, len = list.length; j < len; j++) {\n        elem = list[j];\n        results.push(AnimationUpdater.elements.push(elem));\n      }\n      return results;\n    },\n    add: function (object) {\n      if (indexOf.call(AnimationUpdater.elements, object) < 0) {\n        return AnimationUpdater.elements.push(object);\n      }\n    },\n    run: function (force) {\n      var elem, finished, isCallback, j, k, l, len, ref, toRemove;\n      if (force == null) {\n        force = false;\n      }\n      isCallback = isFinite(parseFloat(force));\n      if (isCallback || force === true) {\n        finished = true;\n        toRemove = [];\n        ref = AnimationUpdater.elements;\n        for (k = j = 0, len = ref.length; j < len; k = ++j) {\n          elem = ref[k];\n          if (elem.update(force === true)) {\n            finished = false;\n          } else {\n            toRemove.push(k);\n          }\n        }\n        for (l = toRemove.length - 1; l >= 0; l += -1) {\n          k = toRemove[l];\n          AnimationUpdater.elements.splice(k, 1);\n        }\n        return (AnimationUpdater.animId = finished\n          ? null\n          : requestAnimationFrame(AnimationUpdater.run));\n      } else if (force === false) {\n        if (AnimationUpdater.animId === !null) {\n          cancelAnimationFrame(AnimationUpdater.animId);\n        }\n        return (AnimationUpdater.animId = requestAnimationFrame(\n          AnimationUpdater.run\n        ));\n      }\n    },\n  };\n\n  if (typeof window.define === \"function\" && window.define.amd != null) {\n    define(function () {\n      return {\n        Gauge: Gauge,\n        Donut: Donut,\n        BaseDonut: BaseDonut,\n        TextRenderer: TextRenderer,\n      };\n    });\n  } else if (typeof module !== \"undefined\" && module.exports != null) {\n    module.exports = {\n      Gauge: Gauge,\n      Donut: Donut,\n      BaseDonut: BaseDonut,\n      TextRenderer: TextRenderer,\n    };\n  } else {\n    window.Gauge = Gauge;\n    window.Donut = Donut;\n    window.BaseDonut = BaseDonut;\n    window.TextRenderer = TextRenderer;\n  }\n}.call(this));\n/*-------------------------------------------------------------------------------*/\n/*------------------------------------BAR GAUGE----------------------------------*/\n/*-------------------------------------------------------------------------------*/\nclass BarGauge {\n  constructor(canvas, isVertical, options) {\n    if (isVertical === undefined || isVertical === null) this.isVertical = true;\n    else this.isVertical = isVertical;\n\n    try {\n      if (!canvas) throw new Error(\"Container is required!\");\n\n      this.canvas = canvas;\n      if (isVertical) {\n        if (this.canvas.width === 0) this.canvas.width = 300;\n        if (this.canvas.height === 0) this.canvas.height = 150;\n      } else {\n        if (this.canvas.width === 0) this.canvas.width = 300;\n        if (this.canvas.height === 0) this.canvas.height = 150;\n      }\n\n      this.canvas.style.width = 300;\n      this.canvas.style.height = 150;\n\n      if (!options) {\n        options = this.getDefaults();\n      }\n\n      this.animId = null;\n      this.value = 0;\n      this.dv = 0; // Change in value (used for animation)\n      this.options = options;\n      this.unit = options.unit;\n      this.ctx = this.canvas.getContext(\"2d\");\n    //   console.log(\"canvas\", canvas, \"ctx\", this.ctx);\n      this.render(this.options.value); //50\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  getDefaults() {\n    return {\n      min: 0,\n      max: 100,\n      value: 50,\n      threshold: null,\n      unit: \"°C\",\n      barBorderColor: \"#CEE9B6\",\n      barLength: this.isVertical ? this.canvas.height : this.canvas.width,\n      barBreadth: 30,\n      barFillColor: \"#DBDBDB\",\n      textColor: \"white\",\n      showLimits: false,\n    };\n  }\n\n  setValue(value) {\n    if(value > this.options.max) value = this.options.max;\n    if(value < this.options.min) value = this.options.min;\n    \n    this.render(value);\n    this.value = value;\n    this.options.value = value;\n  }\n\n  setUnit(unit) {\n    this.unit = unit;\n    this.options.unit = unit;\n\n    this.render(this.value);\n  }\n\n  setMin(min) {\n    this.options.min = min;\n\n    this.render(this.value);\n  }\n\n  setMax(max) {\n    this.options.max = max;\n\n    this.render(this.value);\n  }\n\n  setThreshold(threshValue) {\n    this.options.threshold = threshValue;\n\n    this.render(this.value);\n  }\n\n  setBarLength(length) {\n    this.options.barLength = length;\n\n    if (this.isVertical)\n      this.barElementContainer.css({ height: length + \"px\" });\n    else this.barElementContainer.css({ width: length + \"px\" });\n\n    this.render();\n  }\n\n  _calculateValuePercentage(value) {\n    var min = this.options.min;\n    var max = this.options.max;\n    try {\n      if (min > max) throw new Error(\"Min limit cannot larger than max!\");\n\n      if (value > max || value < min) {\n        this.valueOutOfLimit = true;\n        throw new Error(`Value ${value} is out of limit!`);\n      }\n\n      this.valueOutOfLimit = false;\n\n      return (value - min) / (max - min);\n    } catch (error) {\n      console.log(error);\n      return null;\n    }\n  }\n\n  _calculateValueChangePercentage() {\n    var min = this.options.min;\n    var max = this.options.max;\n    try {\n      if (min > max) throw new Error(\"Min limit has to be larger than max!\");\n\n      if (this.dv > max || this.dv < min) {\n        this.valueOutOfLimit = true;\n        throw new Error(`Value ${this.dv} is out of limit!`);\n      }\n\n      this.valueOutOfLimit = false;\n\n      return (this.dv - min) / (max - min);\n    } catch (error) {\n      console.log(error);\n      return null;\n    }\n  }\n\n  _renderThresholdIndicator(x, y, w, h) {\n    var tipX, tipY, triEdge1X, triEdge1Y, triEdge2X, triEdge2Y;\n    var threshPercent = this._calculateValuePercentage(this.options.threshold);\n\n    this.ctx.beginPath();\n    this.ctx.strokeStyle = \"#111217\";\n    this.ctx.lineWidth = 3;\n    if(this.isVertical){\n        tipX = x;\n        tipY = Math.round((1 - threshPercent) * this.options.barLength);\n    }else{\n        tipX = Math.round(w - (1 - threshPercent) * this.options.barLength);\n        tipY = y;\n    }\n    this.ctx.moveTo(tipX, tipY);\n    if(this.isVertical) this.ctx.lineTo(tipX + this.options.barBreadth, tipY);\n    else this.ctx.lineTo(tipX, tipY + this.options.barBreadth);\n        \n    this.ctx.stroke();\n    // this.ctx.fillStyle = this.options.textColor;\n\n    // var triBase = 15,\n    //   triHeight = 10;\n      \n    // if (this.isVertical) {\n    //   tipX = x + w + 2;\n    //   tipY = Math.round((1 - threshPercent) * this.options.barLength);\n\n    //   triEdge1X = tipX + triHeight;\n    //   triEdge1Y = tipY - triBase / 2;\n\n    //   triEdge2X = tipX + triHeight;\n    //   triEdge2Y = tipY + triBase / 2;\n    // } else {\n    //   tipX = Math.round(w - (1 - threshPercent) * this.options.barLength);\n    //   tipY = y + this.options.barBreadth;\n\n    //   triEdge1X = tipX - triBase / 2;\n    //   triEdge1Y = tipY + triHeight;\n\n    //   triEdge2X = tipX + triBase / 2;\n    //   triEdge2Y = tipY + triHeight;\n    // }\n    // console.table({ threshold: this.options.threshold, tipX, tipY });\n    // this.ctx.moveTo(tipX, tipY);\n    // // this.ctx.lineTo(tipX, tipY + triHeight);\n\n    // this.ctx.lineTo(triEdge1X, triEdge1Y);\n    // this.ctx.lineTo(triEdge2X, triEdge2Y);\n    // this.ctx.fill();\n  }\n\n  _renderValues(value, x, y, w, h) {\n    this.ctx.beginPath();\n    this.ctx.fillStyle = this.options.textColor;\n\n    var valX, valY, maxX, maxY, minX, minY;\n\n    if (this.isVertical) {\n      valX = x - 70;\n      valY = this.canvas.height / 2 + 6;\n      maxX = x + w + 2;\n      maxY = 16;\n      minX = x + w + 2;\n      minY = this.options.barLength;\n    } else {\n      valX = this.options.barLength / 2 - 20;\n      valY = y - 6;\n      maxX = this.options.barLength - 35;\n      maxY = y + this.options.barBreadth + 16;\n      minX = 0;\n      minY = y + this.options.barBreadth + 16;\n    }\n    this.ctx.font = \"24px Tajawal\";\n    this.ctx.fillText(value + this.unit, valX, valY);\n\n    if (this.options.showLimits) {\n      this.ctx.font = \"16px Tajawal\";\n      this.ctx.fillText(this.options.max, maxX, maxY);\n      this.ctx.fillText(this.options.min, minX, minY);\n    }\n  }\n\n  _renderBar(x, y, w, h) {\n    var startX, endX, startY, endY;\n    if (this.isVertical) {\n      startX = x;\n      startY = this.canvas.height;\n\n      endX = startX;\n      endY = this.canvas.height - this.options.barLength;\n    } else {\n      startX = x;\n      startY = y + this.options.barBreadth / 2;\n\n      endX = x + this.options.barLength;\n      endY = startY;\n    }\n\n    var barX, barW, barY, barH;\n    var percent = this._calculateValueChangePercentage();\n\n    if (this.isVertical) {\n      barY = Math.round(y + (1 - percent) * this.options.barLength);\n      barH = Math.round(h - (1 - percent) * this.options.barLength);\n    } else {\n      barX = 0;\n      barW = Math.round(w - (1 - percent) * this.options.barLength);\n    }\n    //   console.table({\n    //     percent,\n    //     isIncrementing,\n    //     newValue: value,\n    //     oldValue: this.value,\n    //     barLength: this.dh,\n    //     barX,\n    //     barW,\n    //     x,\n    //     w,\n    //     barY,\n    //     barH,\n    //     y,\n    //     h,\n    //   });\n    var grdFill = this.ctx.createLinearGradient(startX, startY, endX, endY);\n    var threshPercent = this._calculateValuePercentage(this.options.threshold);\n    grdFill.addColorStop(0, \"#8ADB42\");\n    grdFill.addColorStop(threshPercent, \"#8ADB42\");\n    grdFill.addColorStop(threshPercent, \"#FD5247\");\n\n    // // Gradient\n    // grdFill.addColorStop(0, \"#8ADB42\");\n    // grdFill.addColorStop(0.45, \"#FFEF5C\");\n    // grdFill.addColorStop(1, \"#FD5247\");\n\n    this.ctx.beginPath();\n    this.ctx.fillStyle = grdFill;\n\n    if (this.isVertical) {\n      this.ctx.fillRect(x, barY, w, barH);\n    } else {\n      this.ctx.fillRect(barX, y, barW, h);\n    }\n  }\n\n  render(value) {\n    if (this.animId !== undefined && this.animId !== null)\n      cancelAnimationFrame(this.animId);\n    // console.log(\"hello\", this.options.barLength)\n    var x, y, w, h;\n    var velocity = 3;\n\n    if (this.isVertical) {\n      x = this.canvas.width / 2 - this.options.barBreadth / 2;\n      y = this.canvas.height - this.options.barLength;\n      w = this.options.barBreadth;\n      h = this.options.barLength;\n    } else {\n      x = 0;\n      y = this.canvas.height / 2 - this.options.barBreadth / 2;\n      w = this.options.barLength;\n      h = this.options.barBreadth;\n    }\n\n    var isIncrementing = this.value < value || this.value === value;\n    var mod = isIncrementing ? 1 : -1;\n\n    var animate = function (instance) {\n      instance.ctx.clearRect(\n        0,\n        0,\n        instance.canvas.width,\n        instance.canvas.height\n      );\n\n      // Render value, min, and max texts\n      instance._renderValues(value, x, y, w, h);\n\n      // Render bar container\n      instance.ctx.beginPath();\n      instance.ctx.fillStyle = instance.options.barFillColor;\n      instance.ctx.fillRect(x, y, w, h);\n\n      // Render bar\n      instance._renderBar(x, y, w, h);\n      \n      // Render threshold\n      instance._renderThresholdIndicator(x, y, w, h);\n\n      if (isIncrementing) {\n        if (instance.dv >= value) return;\n      } else {\n        if (instance.dv <= value) return;\n      }\n\n      var nextDv = instance.dv + velocity * mod;\n\n      if (isIncrementing) {\n        // Set the value change to the target value\n        if (nextDv > value) instance.dv = value;\n        else instance.dv = nextDv;\n      } else {\n        if (nextDv < instance.min) instance.dv = instance.min;\n        else instance.dv = nextDv;\n      }\n\n      instance.animId = requestAnimationFrame(() => animate(instance));\n    };\n\n    animate(this);\n  }\n\n  destroy() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.canvas.width = 0;\n    this.canvas.height = 0;\n  }\n}\n\nvar radialGaugeOptions = {\n    angle: 0.3, // The span of the gauge arc\n    lineWidth: 0.16, // The line thickness\n    radiusScale: 1, // Relative radius\n    pointer: {\n        length: 0.6, // // Relative to gauge radius\n        strokeWidth: 0.035, // The thickness\n        color: \"#000000\", // Fill color\n    },\n    limitMax: false, // If false, max value increases automatically if value > maxValue\n    limitMin: false, // If true, the min value of the gauge will be fixed\n    colorStart: \"#CEE9B6\", // Colors\n    colorStop: \"#CEE9B6\", // just experiment with them\n    strokeColor: \"rgba(219,219,219,0.4)\", // to see which ones work best for you\n    generateGradient: true,\n    highDpiSupport: true, // High resolution support\n    gradientFill: false\n};\n\n/*-------------------------------------------------------------------------------*/\n/*-----------------------------------START HERE----------------------------------*/\n/*-------------------------------------------------------------------------------*/\n\nvar ctx;\nvar $scope;\nvar settings;\nvar telemetrySubscription;\nvar entityId;\n// TODO: Remove later\nvar createDefaultRadialGauge = function(canvas, valueElement, value){\n    var gauge = new Donut(canvas).setOptions(radialGaugeOptions);\n    gauge.maxValue = 100;\n    gauge.minValue = 0;\n    gauge.setTextField(valueElement);\n    \n    if(value === undefined || value === null) gauge.set(50);\n    else gauge.set(value);\n    \n    return gauge;\n};\n\nvar onDataUpdated = function(subscription, detectChanges) {\n    if ($scope.isEditMode) return;\n\n    var subscData = subscription.data;\n\n    // console.log(\"onData updated\");\n    // console.log(\"onDataUpdated\", subscription);\n    if (subscData.length < 1) return;\n\n    subscData.forEach(function(keyData) {\n        if (!(keyData && keyData.data && keyData.data[0])) return;\n\n        var updatedDataKey = keyData.dataKey;\n\n        var pinToUpdate = $scope.pins.find(function(pin) {\n            return pin.telemetryKey === updatedDataKey.name;\n        });\n\n        var pinIndex = $scope.pins.findIndex(function(pin) {\n            return pin.telemetryKey === updatedDataKey.name;\n        });\n\n        var pinValueElementToUpdate = $(\".pin-card-radGaugeValue\").eq(pinIndex);\n\n        var newValue = keyData.data[0][1];\n        \n        // console.table({label:pinToUpdate.label, pinIndex, newValue: newValue});\n\n        var pinObj = $scope.pins[pinIndex];\n        \n        if(pinObj.type === \"RADIAL\")\n            pinObj.gaugeInstance.set(newValue);\n        else\n            pinObj.gaugeInstance.setValue(newValue);\n            \n    })\n}\n\nvar onDataUpdateError = function(subscription, e) {\n    console.log(\"onDataUpdatedError\", e);\n}\n\nvar createTelemetryKeysSubscription = function(){\n    var subscriptionOptions = {\n        callbacks: {\n            onDataUpdated: (subscription, detectChanges) => ctx.ngZone.run(() => {\n                onDataUpdated(subscription, detectChanges);\n            }),\n            onDataUpdateError: (subscription, e) => ctx.ngZone.run(() => {\n                onDataUpdateError(subscription, e);\n            }),\n            dataLoading: () => {}\n        }\n    };\n\n    var subscriptionsInfo = [{\n        type: \"entity\",\n        entityType: \"DEVICE\",\n        entityId: ctx.defaultSubscription.targetDeviceId\n    }];\n\n    subscriptionsInfo[0].timeseries = $scope.pins.map(function(pin) {\n        return {\n            name: pin.telemetryKey\n        };\n    });\n        \n    ctx.subscriptionApi.createSubscriptionFromInfo(\"latest\", subscriptionsInfo, subscriptionOptions, false, true).subscribe((subscription) => {\n        // console.log(\"subscription\", subscription);\n        telemetrySubscription = subscription;\n        \n        // Update 'analogPinsConfigName' attribute\n        ctx.attributeService.saveEntityAttributes(entityId, \"SERVER_SCOPE\", [{\n            key: settings.analogPinsConfigName,\n            value: $scope.pins.map(function(pin){\n                return {\n                    label: pin.label,\n                    telemetryKey: pin.telemetryKey,\n                    type: pin.type,\n                    number: pin.number,\n                    nodeId: pin.nodeId,\n                    min: pin.min,\n                    max: pin.max,\n                    unit: pin.unit,\n                    threshold: pin.threshold\n                }\n            })\n        }]).subscribe(function() {\n            // console.log(\"<-------ATTRIBUTE SAVED------->\");\n        });\n    });\n};\n\nself.onInit = function() {\n    ctx = self.ctx;\n    $scope = ctx.$scope;\n    settings = ctx.settings;\n    \n    // console.log(\"ctx\", ctx);\n    \n    entityId = {\n        id: ctx.defaultSubscription.targetDeviceId,\n        entityType: \"DEVICE\"\n    };\n    \n    var pinsListContainerId = \"pins-list-container\";\n    \n    var gaugesListContainer = document.getElementById(pinsListContainerId);\n    \n    $scope.pins = [];\n    $scope.isEditMode = false;\n    $scope.readOnly = settings.readOnly;\n    \n    ctx.instances = [];\n    \n    $scope.addPin = function(){\n        var pin = {\n            label: \"Example-\" + ($scope.pins.length + 1),\n            telemetryKey: \"example\" + ($scope.pins.length + 1),\n            type: \"RADIAL\",\n            number: 0,\n            nodeId: 0,\n            value: 30,\n            unit: \"%\",\n            min: 0,\n            max: 100,\n            gaugeInstance: null\n        };\n        \n        $scope.pins.push(pin);\n    };\n    \n    $scope.removePin = function($event, index, pinObj) {\n        $scope.pins.splice(index, 1);\n    };\n    \n    function saveChanges() {\n        // console.log(\"<-----------SAVING----------->\");\n        // Create subscriptions to telemetry values\n        if(!telemetrySubscription){\n            // console.log(\"<-------CREATE SUBSCRIPTION------->\");\n            createTelemetryKeysSubscription();\n        }else{\n            // console.log(\"<-------UPDATE SUBSCRIPTION------->\");\n            ctx.subscriptionApi.removeSubscription(telemetrySubscription.id);\n            createTelemetryKeysSubscription();\n        }\n    \n    }\n    \n    $scope.toggleEditMode = function() {\n        if($scope.isEditMode) saveChanges();\n\n        $scope.isEditMode = !$scope.isEditMode;\n    };\n    \n    var PinSettingsDialogController = function(vm){\n        vm.errors = [];\n        vm.pinSettingsFormGroup = vm.fb.group({\n            label: [$scope.selectedPin.label, [vm.validators.required]],\n            telemetryKey: [$scope.selectedPin.telemetryKey, [vm.validators.required]],\n            type: [$scope.selectedPin.type, [vm.validators.required]],\n            pinNumber: [$scope.selectedPin.number, [vm.validators.required]],\n            nodeId: [$scope.selectedPin.nodeId, [vm.validators.required]],\n            unit: [$scope.selectedPin.unit],\n            min: [$scope.selectedPin.min, [vm.validators.required]],\n            max: [$scope.selectedPin.max, [vm.validators.required]],\n            threshold: [$scope.selectedPin.threshold, [vm.validators.required]],\n        });\n        \n        var checkErrors = function(formValues){\n            var {telemetryKey, max, min, threshold} = formValues;\n            var errors = [];\n            // Check if telemetry key exists\n            var telemetryKeyExists = $scope.pins.some(function(pin){return pin.telemetryKey === telemetryKey});\n            \n            var isSelectedPinTelemetryKey = $scope.pins[$scope.selectedPinIndex].telemetryKey === telemetryKey\n            \n            if(telemetryKeyExists && !isSelectedPinTelemetryKey) errors.push(\"Telemetry key(s) already exists\");\n            // Check if minimum > maximum\n            if(min > max || min === max) errors.push(\"Maximum value must be larger than minimum\")\n            \n            // Check if all required fields are not Empty\n            var unRequiredFields = [\"unit\"]\n            \n            var hasEmptyInputs = Object.keys(formValues).some(function(field){\n                var value = formValues[field];\n                \n                return !unRequiredFields.includes(field) && (value === \"\" || value === undefined || value === null);\n            })\n            \n            if(hasEmptyInputs) errors.push(\"Some required fields are empty\")\n            \n            if(threshold < min || threshold > max) errors.push(\"Threshold value is out of limit\")\n            \n            // console.log(\"errors\", errors)\n            return errors;\n        }\n        \n        vm.cancel = function() {\n            vm.dialogRef.close(null);\n        };\n        \n        vm.save = function(){\n            // console.log(\"<-----------SAVING------------>\");\n            var formValues = vm.pinSettingsFormGroup.value;\n            var {max, min, label, telemetryKey, type, nodeId, pinNumber, unit, threshold} = formValues;\n            \n            var errors = checkErrors(formValues);\n            \n            if(errors.length > 0){\n                vm.errors = errors;\n                return;\n            }\n            // console.log(\"Form values\", formValues);\n            \n            var pinIndex = $scope.selectedPinIndex;\n            var pin = $scope.pins[pinIndex];\n            \n            pin.max = max;\n            pin.min = min;\n            pin.label = label;\n            pin.telemetryKey = telemetryKey;\n            pin.nodeId = nodeId;\n            pin.number = pinNumber;\n            pin.unit = unit;\n            pin.threshold = threshold;\n            \n            // Update UI\n            $(\".pin-card .pin-card-label\").eq(pinIndex).text(label);\n            $(\".pin-card .pin-card-nodeId\").eq(pinIndex).text(nodeId);\n            $(\".pin-card .pin-card-pinNumber\").eq(pinIndex).text(pinNumber);\n            \n            var prevType = pin.type;\n            var currentType = type;\n            // Change gauge instance accordingly\n            if(prevType !== currentType){\n                var radGaugeValueElement = $(\".pin-card .pin-card-radGaugeValue\").eq(pinIndex);\n                var radGaugeUnitElement = $(\".pin-card .pin-card-radGaugeUnit\").eq(pinIndex);\n                var radGaugeCanvasElement = $(\".pin-card .pin-card-radialGauge\").eq(pinIndex);\n                \n                var barGaugeContainer = $(\".pin-card .pin-card-barGauge\").eq(pinIndex);\n                \n                // Clear/destroy previous gauge instance\n                if(prevType === \"RADIAL\"){\n                    radGaugeValueElement.html(\"\");\n                    radGaugeUnitElement.html(\"\");\n                    \n                    radGaugeCanvasElement.css(\"width\", 0);\n                    radGaugeCanvasElement.css(\"height\", 0);\n                }else{\n                    pin.gaugeInstance.destroy();\n                }\n                \n                // Create new gauge instance\n                if(currentType === \"RADIAL\"){\n                    radGaugeCanvasElement.css(\"width\", \"100%\");\n                    radGaugeCanvasElement.css(\"height\", \"150px\");\n                    \n                    pin.gaugeInstance = new Donut(radGaugeCanvasElement[0]).setOptions(radialGaugeOptions);\n                    \n                    var gaugeInstance = pin.gaugeInstance;\n                    \n                    gaugeInstance.maxValue = max;\n                    gaugeInstance.setMinValue(min);\n                    gaugeInstance.setThreshold(threshold);\n                    gaugeInstance.set(pin.value);\n                    \n                    radGaugeUnitElement.text(unit);\n                }else {\n                    var barGaugeOptions = {\n                        max: max,\n                        min: min,\n                        value: min,\n                        unit: unit,\n                        barFillColor: \"rgba(219,219,219,0.4)\",\n                        barLength: currentType === \"VBAR\" ? 150 : 300,\n                        barBreadth: 30,\n                        textColor: \"white\",\n                        threshold: threshold\n                    };\n                    \n                    pin.gaugeInstance = new BarGauge(barGaugeContainer[0], currentType === \"VBAR\", barGaugeOptions);\n                }\n            }else{\n                if(currentType === \"RADIAL\"){\n                    var gaugeInstance = pin.gaugeInstance;\n                    \n                    gaugeInstance.maxValue = max;\n                    gaugeInstance.setMinValue(min);\n                    gaugeInstance.setThreshold(threshold);\n                    gaugeInstance.set(pin.value);\n                }\n            }\n            \n            pin.type = type;\n            // Set values and unit of gauge instance\n            if(currentType !== \"RADIAL\"){\n                pin.gaugeInstance.setMax(max);\n                pin.gaugeInstance.setMin(min);\n                \n                pin.gaugeInstance.setUnit(unit);\n                pin.gaugeInstance.setThreshold(threshold)\n            }\n            \n            vm.pinSettingsFormGroup.markAsPristine();\n            vm.dialogRef.close(null);\n            // console.log($scope.pins);\n        //     ctx.showSuccessToast(\"Pin states saved!\");\n        };\n        \n    };\n    \n    $scope.openSettingsDialog = function($event, pin, pinIndex){\n        // console.log(\"selected pin\", pinIndex, pin)\n        $scope.selectedPin = pin || {};\n        $scope.selectedPinIndex = pinIndex;\n        \n        var pinSettingsHtml = `\n        <style>\n            .pin-settings-form input{\n                transition: box-shadow 300ms ease;\n            }\n            .pin-settings-form input:focus{\n                outline: none;\n            \tbox-shadow: inset 0 0 0 2px #7d7d7d;\n            }\n            .pin-settings-form label{\n                display: block;\n                font-size: 14px;\n                color: #969696;\n                margin-bottom: 2px;\n            }\n            .pin-settings-form .required-asterisk{\n                color: red;\n            }\n            .pin-settings-form select{\n                width: 100%\n            }\n        </style>\n        <form #pinSettingsForm=\"ngForm\" [formGroup]=\"pinSettingsFormGroup\" (ngSubmit)=\"save()\" style=\"min-width: 400px\" class=\"pin-settings-form\">\n            <mat-toolbar fxLayout=\"row\" color=\"primary\">\n                <h2>Analog Pin Settings</h2>\n                <span fxFlex></span>\n                <button mat-icon-button (click)=\"cancel()\" type=\"button\">\n                    <mat-icon class=\"material-icons\">close</mat-icon>\n                </button>\n            </mat-toolbar>\n            <mat-progress-bar color=\"warn\" mode=\"indeterminate\" *ngIf=\"isLoading$ | async\">\n            </mat-progress-bar>\n            <div style=\"height: 4px;\" *ngIf=\"!(isLoading$ | async)\"></div>\n            <div mat-dialog-content fxLayout=\"column\" fxLayoutGap=\"12px\">\n                <div *ngIf=\"errors.length\" style=\"border-radius: 4px; background-color: #ffe3e4; color: #d40012; padding: 6px 8px; font-size: 12px\">\n                    <ul>\n                        <li *ngFor=\"let error of errors\">{{error}}</li>\n                    </ul>\n                </div>\n                <div class=\"form-field\">\n                    <label>\n                        Pin Label <span class=\"required-asterisk\">*</span>\n                    </label>\n                    <input type=\"text\" matInput formControlName=\"label\"  fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                </div>\n                <div class=\"form-field\">\n                    <label>\n                        Telemetry Key <span class=\"required-asterisk\">*</span>\n                    </label>\n                    <input type=\"text\" matInput formControlName=\"telemetryKey\"  fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                </div>\n                <div class=\"form-field\">\n                    <label>Unit</label>\n                    <input type=\"text\" matInput formControlName=\"unit\"  fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\">\n                </div>\n                <!--<div fxLayout fxLayoutAlign=\"space-between\" style=\"gap: 12px\">-->\n                    <div class=\"form-field\">\n                        <label>\n                            Gauge Type <span class=\"required-asterisk\">*</span>\n                        </label>\n                        <select matInput formControlName=\"type\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                            <option value=\"RADIAL\">Radial</option>\n                            <option value=\"VBAR\">Vertical Bar</option>\n                            <option value=\"HBAR\">Horizontal Bar</option>\n                        </select>\n                    </div>\n                    <div class=\"form-field\">\n                        <label>\n                            Threshold <span class=\"required-asterisk\">*</span>\n                        </label>\n                        <input type=\"number\" matInput formControlName=\"threshold\" fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                    </div>\n                <!--</div>-->\n                <div fxLayout fxLayoutAlign=\"space-between\" style=\"gap: 12px\">\n                    <div class=\"form-field\">\n                        <label>\n                            Node ID <span class=\"required-asterisk\">*</span>\n                        </label>\n                        <input type=\"number\" matInput formControlName=\"nodeId\"  fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                    </div>\n                    <div class=\"form-field\">\n                        <label>\n                            Pin Number <span class=\"required-asterisk\">*</span>\n                        </label>\n                        <input type=\"number\" matInput formControlName=\"pinNumber\"  fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                    </div>\n                </div>\n                <div fxLayout fxLayoutAlign=\"space-between\" style=\"gap: 12px\">\n                    <div class=\"form-field\">\n                        <label>\n                            Min <span class=\"required-asterisk\">*</span>\n                        </label>\n                        <input type=\"number\" matInput formControlName=\"min\"  fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                    </div>\n                    <div class=\"form-field\">\n                        <label>\n                            Max <span class=\"required-asterisk\">*</span>\n                        </label>\n                        <input type=\"number\" matInput formControlName=\"max\" fxFlex=\"1 1 100%\" style=\"display: block; height: 38px; padding: 5px 8px; border: 1px solid #0000001f; border-radius: 4px;\" required>\n                    </div>\n                </div>\n            </div>\n            <div mat-dialog-actions fxLayout=\"row\" fxLayoutAlign=\"end center\">\n                <button mat-button mat-raised-button color=\"primary\" type=\"submit\" [disabled]=\"(isLoading$ | async)\">\n                    Save\n                </button>\n            </div>\n        </form>\n        `;\n        ctx.customDialog.customDialog(pinSettingsHtml, PinSettingsDialogController).subscribe();  \n    };\n    \n    ctx.ngZone.run(function() {\n        // console.log(\"settings\", settings.analogPinsConfigName)\n        const observer = new MutationObserver(function(mutationsList) {\n            // console.log(\"mutations list\", mutationsList);\n            mutationsList.forEach(function(mutation, i) {\n                mutation.addedNodes.forEach(function(addedNode) {\n    \t\t\t\tif(addedNode.classList.contains(\"pin-card\")){\n    \t\t\t\t    var pinIndex = parseInt($(addedNode).data(\"pin-index\"));\n    \t\t\t\t    var pin = $scope.pins[pinIndex];\n    \t\t\t\t    var {min, max, unit, type, threshold} = pin;\n    \t\t\t\t    var gaugeInstance;\n    \t\t\t\t    var pinCardGaugeContainer = $(addedNode).children(\".pin-card-gaugeContainer\");\n    \t\t\t\t    \n    \t\t\t\t    var radGaugeCanvasElement = pinCardGaugeContainer.children(\"canvas.pin-card-radialGauge\");\n    \t\t\t\t    var radGaugeValueElement = pinCardGaugeContainer.children(\".pin-card-radGaugeValUnit\").children(\".pin-card-radGaugeValue\");\n    \t\t\t\t    var radGaugeUnitElement = pinCardGaugeContainer.children(\".pin-card-radGaugeValUnit\").children(\".pin-card-radGaugeUnit\");\n    \t\t\t\t    \n    \t\t\t\t    if(type === \"RADIAL\"){\n    \t\t\t\t        gaugeInstance = new Donut(radGaugeCanvasElement[0]).setOptions(radialGaugeOptions);\n    \t\t\t\t        \n    \t\t\t\t        gaugeInstance.setTextField(radGaugeValueElement[0])\n    \t\t\t\t        gaugeInstance.maxValue = max;\n    \t\t\t\t        gaugeInstance.setMinValue(min);\n    \t\t\t\t        gaugeInstance.setThreshold(threshold)\n    \t\t\t\t        gaugeInstance.set(min);\n    \t\t\t\t        radGaugeUnitElement.text(unit);\n    \t\t\t\t    }else{\n    \t\t\t\t        // Remove unit from radial gauge uint elements\n    \t\t\t\t        radGaugeUnitElement.hide();\n    \t\t\t\t        radGaugeCanvasElement.hide();\n    \t\t\t\t        \n    \t\t\t\t        var canvasElement = pinCardGaugeContainer.children(\"canvas.pin-card-barGauge\")[0];\n    \t\t\t\t        // console.log(\"bar gauge canvas\", canvasElement);\n    \t\t\t\t        gaugeInstance = new BarGauge(canvasElement, type === \"VBAR\",\n    \t\t\t\t        {\n                                min: min,\n                                max: max,\n                                value: min,\n                                unit: unit,\n                                barFillColor: \"rgba(219,219,219,0.4)\",\n                                barLength: type === \"VBAR\" ? 150 : 300,\n                                barBreadth: 30,\n                                textColor: \"white\",\n                                threshold: threshold === undefined ? max - (0.8 * max) : threshold\n                            });\n    \t\t\t\t    }\n    \t\t\t\t    $scope.pins[pinIndex].gaugeInstance = gaugeInstance;\n    \t\t\t\t    \n    \t\t\t\t    // console.log( \"modded pin\", $scope.pins[pinIndex]);\n    \t\t\t\t}\n    \t\t\t\t// observer.disconnect();\n        \t\t});\n        \t});\n        });\n        // console.log(ctx)\n        var pinsListContainer = document.getElementById(pinsListContainerId);\n        // console.log(\"pinslistcontainer\", pinsListContainer);\n        observer.observe(pinsListContainer, { subtree: false, childList: true });\n        // console.log(\"uuid\", entityId)\n        if(ctx.defaultSubscription.targetDeviceId){\n            ctx.attributeService.getEntityAttributes(entityId, \"SERVER_SCOPE\", [settings.analogPinsConfigName]).subscribe(function(data){\n                // console.log(\"<----------Getting Attributes---------->\");\n                if (data.length < 1) return;\n                // console.log(\"data\", data);\n                $scope.pins = data[0].value;\n                \n                if($scope.pins.length < 1) return;\n                \n                // $scope.pins.forEach(function(pinData){\n                //     $scope.renderPin(pinData);\n                // });\n                createTelemetryKeysSubscription();\n            });\n        }\n    });\n};\n\n\nself.onResize = function() {\n    \n};\n\nself.onDestroy = function() {\n};\n",
      "settingsSchema" : "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"States Widget\",\n        \"properties\": {\n            \"pinCardWidth\": {\n                \"title\": \"Gauge Width (px)\",\n                \"type\": \"number\",\n                \"default\": 200\n            },\n            \"gap\": {\n                \"title\": \"Gap\",\n                \"type\": \"number\",\n                \"default\": 4\n            },\n            \"analogPinsConfigName\": {\n                \"title\": \"Analog Pins Configuration Name\",\n                \"type\": \"string\",\n                \"default\": \"gaugesConfig\"\n            },\n            \"readOnly\": {\n                \"title\": \"Read Only\",\n                \"type\": \"boolean\",\n                \"default\": true\n            }\n        },\n        \"required\": [\"analogPinsConfigName\"]\n    },\n    \"form\": [\n        \"gaugeWidth\",\n        \"gap\",\n        \"analogPinsConfigName\",\n        \"readOnly\"\n    ]\n}",
      "dataKeySettingsSchema" : "{}\n",
      "defaultConfig" : "{\"targetDeviceAliases\":[],\"showTitle\":true,\"backgroundColor\":\"#111217\",\"color\":\"#ffffff\",\"padding\":\"8px\",\"settings\":{\"gap\":4,\"readOnly\":true,\"analogPinsConfigName\":\"gaugesConfig\"},\"title\":\"Analog Pins (Legacy)\",\"showTitleIcon\":false,\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":true,\"widgetStyle\":{},\"widgetCss\":\"\",\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"noDataDisplayMessage\":\"\",\"showLegend\":false}"
    },
    "externalId" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "ec46d6c0-77dc-11ee-819d-0f0d9d5d78ac"
    }
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}